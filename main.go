package main

import (
	"context"      // Import context package for database operations
	"database/sql" // Import sql package for database connection
	"errors"
	"fmt"
	"log"  // For logging fatal errors
	"os"   // For command-line arguments and exiting
	"strconv" // For parsing integer arguments
	"time" // Import time package for timestamps

	"gator/internal/config"       // Your custom config package
	"gator/internal/database"     // The Go code generated by sqlc
	"gator/internal/rss"          // Your RSS parsing package

	"github.com/lib/pq"           // PostgreSQL driver, now directly imported to use pq.Error
	"github.com/google/uuid"      // UUID package for generating IDs
)

// state holds application-wide data, like the config, database queries, and current user.
type state struct {
	db          *database.Queries // A pointer to the generated database queries object
	cfg         *config.Config      // A pointer to the application configuration
	currentUser *database.User    // The currently logged-in user's database record
}

// command represents a parsed command from the CLI arguments.
type command struct {
	name string   // The name of the command (e.g., "login", "register", "users", "agg", "addfeed", "feeds", "follow", "following", "unfollow", "browse")
	args []string // The arguments passed to the command
}

// commands holds a map of command names to their handler functions.
type commands struct {
	handlers map[string]func(*state, command) error
}

// newCommands initializes and returns a new commands struct with an empty map.
func newCommands() *commands {
	return &commands{
		handlers: make(map[string]func(*state, command) error),
	}
}

// run executes a command if its handler is registered.
func (c *commands) run(s *state, cmd command) error {
	handler, ok := c.handlers[cmd.name]
	if !ok {
		return fmt.Errorf("unknown command: %s", cmd.name)
	}
	return handler(s, cmd)
}

// register registers a new handler function for a command name.
func (c *commands) register(name string, f func(*state, command) error) {
	c.handlers[name] = f
}

// middlewareLoggedIn is a higher-order function that wraps a handler,
// ensuring a user is logged in and passing the user object to the wrapped handler.
// It takes a handler of the "logged in" type (that expects a user argument)
// and returns a "normal" handler that can be registered.
func middlewareLoggedIn(handler func(s *state, cmd command, user database.User) error) func(*state, command) error {
	return func(s *state, cmd command) error {
		// Check if a user is currently logged in.
		if s.currentUser == nil {
			return errors.New("no user is currently logged in. Please login or register first.")
		}
		// If a user is logged in, call the original handler with the user object.
		return handler(s, cmd, *s.currentUser) // Dereference s.currentUser to pass the value
	}
}

// handlerLogin is the handler function for the "login" command.
// Usage: gator login <username>
func handlerLogin(s *state, cmd command) error {
	if len(cmd.args) == 0 {
		return errors.New("login command requires a username argument")
	}
	username := cmd.args[0]

	// Check if the user exists in the database using the generated GetUser query.
	_, err := s.db.GetUser(context.Background(), username)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return fmt.Errorf("user '%s' does not exist in the database", username)
		}
		return fmt.Errorf("failed to check user existence: %w", err)
	}

	// If user exists, set them as the current user in the config and save it.
	err = s.cfg.SetUser(username)
	if err != nil {
		return fmt.Errorf("failed to set user in config: %w", err)
	}

	fmt.Printf("User set to '%s'\n", username)
	return nil
}

// handlerRegister is the handler function for the "register" command.
// Usage: gator register <username>
func handlerRegister(s *state, cmd command) error {
	if len(cmd.args) == 0 {
		return errors.New("register command requires a username argument")
	}
	username := cmd.args[0]

	// First, check if a user with this username already exists to prevent duplicates.
	_, err := s.db.GetUser(context.Background(), username)
	if err == nil {
		return fmt.Errorf("user '%s' already exists", username)
	}
	if !errors.Is(err, sql.ErrNoRows) {
		return fmt.Errorf("failed to check for existing user: %w", err)
	}

	// If we reach here, the user does not exist, so we can create them.
	now := time.Now().UTC()
	params := database.CreateUserParams{
		ID:        uuid.New(),
		CreatedAt: now,
		UpdatedAt: now,
		Name:      username,
	}

	user, err := s.db.CreateUser(context.Background(), params)
	if err != nil {
		return fmt.Errorf("failed to create user: %w", err)
	}

	// After successful creation, set this new user as the current user in the config.
	err = s.cfg.SetUser(username)
	if err != nil {
		return fmt.Errorf("failed to set current user in config after registration: %w", err)
	}

	fmt.Printf("User '%s' created and set as current user.\n", user.Name)
	log.Printf("Created user: %+v\n", user)
	return nil
}

// handlerReset is the handler function for the "reset" command.
// It deletes all users from the database, effectively resetting its state.
// Usage: gator reset
func handlerReset(s *state, cmd command) error {
	err := s.db.DeleteUsers(context.Background())
	if err != nil {
		return fmt.Errorf("failed to delete all users: %w", err)
	}

	fmt.Println("All users deleted. Database reset to a blank state.")
	return nil
}

// handlerUsers is the handler function for the "users" command.
// It lists all users in the database and indicates the current user.
// Usage: gator users
func handlerUsers(s *state, cmd command) error {
	users, err := s.db.GetUsers(context.Background())
	if err != nil {
		return fmt.Errorf("failed to retrieve users: %w", err)
	}

	if len(users) == 0 {
		fmt.Println("No users found.")
		return nil
	}

	fmt.Println("Users:")
	for _, user := range users {
		status := ""
		if user.Name == s.cfg.CurrentUserName {
			status = " (current)"
		}
		fmt.Printf("* %s%s\n", user.Name, status)
	}
	return nil
}

// parseRSSPubDate attempts to parse an RSS pubDate string into a sql.NullTime.
// It tries common RSS date formats.
func parseRSSPubDate(pubDateStr string) sql.NullTime {
	if pubDateStr == "" {
		return sql.NullTime{Valid: false}
	}

	// Common RSS date formats (RFC1123Z is most common for RSS)
	layouts := []string{
		time.RFC1123Z, // "Mon, 02 Jan 2006 15:04:05 -0700"
		time.RFC1123,  // "Mon, 02 Jan 2006 15:04:05 MST"
		time.RFC822,   // "02 Jan 06 15:04 MST"
		// Add other common RSS date formats if you encounter them in feeds:
		// "Mon, 02 Jan 2006 15:04:05 GMT",
		// "2006-01-02T15:04:05Z", // ISO 8601 often seen in Atom, sometimes RSS
	}

	for _, layout := range layouts {
		t, err := time.Parse(layout, pubDateStr)
		if err == nil {
			return sql.NullTime{Time: t.UTC(), Valid: true} // Store in UTC
		}
	}
	log.Printf("Warning: Could not parse PubDate '%s' with known layouts. Storing as NULL.", pubDateStr)
	return sql.NullTime{Valid: false}
}


// scrapeFeeds is the core aggregation function that fetches and processes a single feed.
func scrapeFeeds(s *state) {
	ctx := context.Background() // Use a background context for the scraping operation

	// 1. Get the next feed to fetch from the DB.
	feed, err := s.db.GetNextFeedToFetch(ctx)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			log.Println("No feeds to fetch. Waiting for new feeds...")
			return
		}
		log.Printf("Error getting next feed to fetch: %v", err)
		return
	}

	log.Printf("Fetching feed '%s' from URL: %s", feed.Name, feed.Url)

	// 2. Mark it as fetched (update last_fetched_at and updated_at).
	now := time.Now().UTC()
	markParams := database.MarkFeedFetchedParams{
		LastFetchedAt: sql.NullTime{Time: now, Valid: true}, // last_fetched_at is nullable, so use sql.NullTime
		UpdatedAt:     now,
		ID:            feed.ID,
	}
	err = s.db.MarkFeedFetched(ctx, markParams)
	if err != nil {
		log.Printf("Error marking feed '%s' as fetched: %v", feed.Name, err)
		// Continue attempting to fetch, as marking fetched is not critical for the current fetch
	}

	// 3. Fetch the feed using the URL (we already wrote this function).
	rssFeed, err := rss.FetchFeed(ctx, feed.Url)
	if err != nil {
		log.Printf("Error fetching or parsing RSS feed '%s' from %s: %v", feed.Name, feed.Url, err)
		return
	}

	// 4. Iterate over the items in the feed and save them to the database.
	log.Printf("Successfully fetched %d items from feed '%s'. Saving posts...", len(rssFeed.Channel.Item), feed.Name)
	for _, item := range rssFeed.Channel.Item {
		postNow := time.Now().UTC()
		// Parse published_at, handling potential errors and nulls
		publishedAt := parseRSSPubDate(item.PubDate)

		createPostParams := database.CreatePostParams{
			ID:          uuid.New(),
			CreatedAt:   postNow,
			UpdatedAt:   postNow,
			Title:       item.Title,
			Url:         item.Link,
			Description: sql.NullString{String: item.Description, Valid: item.Description != ""}, // Handle empty description
			PublishedAt: publishedAt,
			FeedID:      feed.ID,
		}

		_, err := s.db.CreatePost(ctx, createPostParams)
		if err != nil {
			// If it's a unique constraint violation (post with same URL already exists), ignore it.
			if pqErr, ok := err.(*pq.Error); ok && pqErr.Code.Name() == "unique_violation" {
				// log.Printf("Info: Post with URL '%s' already exists. Skipping.", item.Link) // Optional: log if you want to see these
				continue // Skip to the next item
			}
			// For other errors, log them.
			log.Printf("Error saving post '%s' from feed '%s': %v", item.Title, feed.Name, err)
		} else {
			// log.Printf("Saved post: '%s'", item.Title) // Optional: log successful saves
		}
	}
	log.Printf("Finished saving posts for feed '%s'.", feed.Name)
}

// handlerAgg is the handler function for the "agg" command.
// It runs the feed aggregation in a long-running loop.
// Usage: gator agg <time_between_reqs> (e.g., 1s, 1m, 1h)
func handlerAgg(s *state, cmd command) error {
	if len(cmd.args) < 1 {
		return errors.New("agg command requires a time_between_reqs argument (e.g., 1s, 1m, 1h)")
	}
	durationString := cmd.args[0]

	timeBetweenRequests, err := time.ParseDuration(durationString)
	if err != nil {
		return fmt.Errorf("invalid duration string '%s': %w", durationString, err)
	}

	fmt.Printf("Collecting feeds every %s\n", timeBetweenRequests.String())
	fmt.Println("Press Ctrl+C to stop.")

	ticker := time.NewTicker(timeBetweenRequests)
	defer ticker.Stop()

	// Run immediately once, then on each tick
	scrapeFeeds(s) // Initial run
	for ; ; <-ticker.C {
		scrapeFeeds(s)
	}
}

// handlerAddFeed is the handler function for the "addfeed" command.
// Usage: gator addfeed <name> <url>
func handlerAddFeed(s *state, cmd command, user database.User) error {
	if len(cmd.args) < 2 {
		return errors.New("addfeed command requires a name and a URL argument")
	}
	feedName := cmd.args[0]
	feedURL := cmd.args[1]

	now := time.Now().UTC()
	params := database.CreateFeedParams{
		ID:        uuid.New(),
		CreatedAt: now,
		UpdatedAt: now,
		Name:      feedName,
		Url:       feedURL,
		UserID:    user.ID,
	}

	feed, err := s.db.CreateFeed(context.Background(), params)
	if err != nil {
		if pqErr, ok := err.(*pq.Error); ok && pqErr.Code.Name() == "unique_violation" {
			return fmt.Errorf("a feed with URL '%s' already exists", feedURL)
		}
		return fmt.Errorf("failed to add feed: %w", err)
	}

	fmt.Printf("Feed added successfully:\n")
	fmt.Printf("  ID: %s\n", feed.ID)
	fmt.Printf("  Name: %s\n", feed.Name)
	fmt.Printf("  URL: %s\n", feed.Url)
	fmt.Printf("  User ID: %s\n", feed.UserID)

	// Automatically create a feed follow record for the current user
	followParams := database.CreateFeedFollowParams{
		ID:        uuid.New(),
		CreatedAt: now,
		UpdatedAt: now,
		UserID:    user.ID,
		FeedID:    feed.ID,
	}

	feedFollow, err := s.db.CreateFeedFollow(context.Background(), followParams)
	if err != nil {
		log.Printf("Warning: Failed to automatically follow new feed '%s' for user '%s': %v", feed.Name, user.Name, err)
	} else {
		fmt.Printf("  Automatically followed by '%s'\n", feedFollow.UserName)
	}

	return nil
}

// handlerFeeds is the handler function for the "feeds" command.
// It lists all feeds in the database, including the name of the user who created it.
// Usage: gator feeds
func handlerFeeds(s *state, cmd command) error {
	feeds, err := s.db.GetFeeds(context.Background())
	if err != nil {
		return fmt.Errorf("failed to retrieve feeds: %w", err)
	}

	if len(feeds) == 0 {
		fmt.Println("No feeds found.")
		return nil
	}

	fmt.Println("Feeds:")
	for _, feed := range feeds {
		fmt.Printf("  Name: %s\n", feed.Name)
		fmt.Printf("  URL: %s\n", feed.Url)
		fmt.Printf("  Added by: %s\n", feed.UserName)
		fmt.Println("---")
	}
	return nil
}

// handlerFollow is the handler function for the "follow" command.
// It allows the current user to follow an existing feed by its URL.
// Usage: gator follow <feed_url>
func handlerFollow(s *state, cmd command, user database.User) error {
	if len(cmd.args) < 1 {
		return errors.New("follow command requires a feed URL argument")
	}
	feedURL := cmd.args[0]

	// 1. Find the feed by URL
	feed, err := s.db.GetFeedByUrl(context.Background(), feedURL)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return fmt.Errorf("feed with URL '%s' not found. Please add it first.", feedURL)
		}
		return fmt.Errorf("failed to lookup feed by URL: %w", err)
	}

	// 2. Create the feed follow record
	now := time.Now().UTC()
	params := database.CreateFeedFollowParams{
		ID:        uuid.New(),
		CreatedAt: now,
		UpdatedAt: now,
		UserID:    user.ID,
		FeedID:    feed.ID,
	}

	feedFollow, err := s.db.CreateFeedFollow(context.Background(), params)
	if err != nil {
		if pqErr, ok := err.(*pq.Error); ok && pqErr.Code.Name() == "unique_violation" {
			return fmt.Errorf("you are already following feed '%s'", feed.Name)
		}
		return fmt.Errorf("failed to follow feed '%s': %w", feed.Name, err)
	}

	fmt.Printf("User '%s' is now following feed '%s'\n", feedFollow.UserName, feedFollow.FeedName)
	return nil
}

// handlerFollowing is the handler function for the "following" command.
// It lists all feeds that the current user is following.
// Usage: gator following
func handlerFollowing(s *state, cmd command, user database.User) error {
	feedFollows, err := s.db.GetFeedFollowsForUser(context.Background(), user.ID)
	if err != nil {
		return fmt.Errorf("failed to retrieve followed feeds for user '%s': %w", user.Name, err)
	}

	if len(feedFollows) == 0 {
		fmt.Printf("User '%s' is not following any feeds.\n", user.Name)
		return nil
	}

	fmt.Printf("Feeds followed by '%s':\n", user.Name)
	for _, ff := range feedFollows {
		fmt.Printf("* %s\n", ff.FeedName)
	}
	return nil
}

// handlerUnfollow is the handler function for the "unfollow" command.
// It allows the current user to unfollow a feed by its URL.
// Usage: gator unfollow <feed_url>
func handlerUnfollow(s *state, cmd command, user database.User) error {
	if len(cmd.args) < 1 {
		return errors.New("unfollow command requires a feed URL argument")
	}
	feedURL := cmd.args[0]

	// 1. Find the feed by URL
	feed, err := s.db.GetFeedByUrl(context.Background(), feedURL)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return fmt.Errorf("feed with URL '%s' not found. Cannot unfollow a non-existent feed.", feedURL)
		}
		return fmt.Errorf("failed to lookup feed by URL: %w", err)
	}

	// 2. Delete the feed follow record
	params := database.DeleteFeedFollowParams{
		UserID: user.ID,
		FeedID: feed.ID,
	}
	err = s.db.DeleteFeedFollow(context.Background(), params)
	if err != nil {
		return fmt.Errorf("failed to unfollow feed '%s': %w", feed.Name, err)
	}

	fmt.Printf("User '%s' has unfollowed feed '%s'.\n", user.Name, feed.Name)
	return nil
}

// handlerBrowse is the handler function for the "browse" command.
// It lists posts from feeds the current user follows, with an optional limit.
// Usage: gator browse [limit]
func handlerBrowse(s *state, cmd command, user database.User) error {
	limit := 2 // Default limit

	if len(cmd.args) > 0 {
		parsedLimit, err := strconv.Atoi(cmd.args[0])
		if err != nil {
			return fmt.Errorf("invalid limit argument '%s': must be an integer", cmd.args[0])
		}
		if parsedLimit < 1 {
			return errors.New("limit must be a positive integer")
		}
		limit = parsedLimit
	}

	posts, err := s.db.GetPostsForUser(context.Background(), database.GetPostsForUserParams{
		UserID: user.ID,
		Limit:  int32(limit), // Cast to int32 as required by sqlc generated type
	})
	if err != nil {
		return fmt.Errorf("failed to retrieve posts for user '%s': %w", user.Name, err)
	}

	if len(posts) == 0 {
		fmt.Printf("No posts found for user '%s'. Try adding and following some feeds, then run 'gator agg'.\n", user.Name)
		return nil
	}

	fmt.Printf("Recent posts for '%s' (Limit: %d):\n", user.Name, limit)
	for _, post := range posts {
		fmt.Printf("--- Post ---\n")
		fmt.Printf("Title: %s\n", post.Title)
		fmt.Printf("URL: %s\n", post.Url)
		if post.PublishedAt.Valid {
			fmt.Printf("Published At: %s\n", post.PublishedAt.Time.Format(time.RFC822)) // Format for readability
		} else {
			fmt.Printf("Published At: N/A\n")
		}
		if post.Description.Valid {
			fmt.Printf("Description: %s\n", post.Description.String)
		} else {
			fmt.Printf("Description: N/A\n")
		}
		fmt.Println("------------")
	}
	return nil
}


func main() {
	// 1. Read the config file from the user's home directory.
	cfg, err := config.Read()
	if err != nil {
		log.Fatalf("Error reading config: %v", err)
	}

	// 2. Open a connection to the PostgreSQL database using the URL from the config.
	dbConn, err := sql.Open("postgres", cfg.DBURL)
	if err != nil {
		log.Fatalf("Error opening database connection: %v", err)
	}
	// Defer closing the database connection until the main function exits.
	defer func() {
		if closeErr := dbConn.Close(); closeErr != nil {
			log.Printf("Error closing database connection: %v", closeErr)
		}
	}()

	// Ping the database to ensure the connection is active and valid.
	err = dbConn.Ping()
	if err != nil {
		log.Fatalf("Error connecting to the database: %v", err)
	}

	// 3. Create a new *database.Queries object using the opened database connection.
	dbQueries := database.New(dbConn)

	// 4. Determine the current user based on the config and fetch their database record.
	var currentUser *database.User
	if cfg.CurrentUserName != "" {
		user, err := dbQueries.GetUser(context.Background(), cfg.CurrentUserName)
		if err != nil {
			log.Printf("Warning: Configured user '%s' not found in database. Please login or register.", cfg.CurrentUserName)
			currentUser = nil
		} else {
			currentUser = &user
		}
	}

	// 5. Initialize the application state with the loaded config, database queries, and current user.
	appState := &state{cfg: &cfg, db: dbQueries, currentUser: currentUser}

	// 6. Create a new instance of the commands registry.
	cmdRegistry := newCommands()

	// 7. Register all known command handlers with the registry.
	cmdRegistry.register("login", handlerLogin)
	cmdRegistry.register("register", handlerRegister)
	cmdRegistry.register("reset", handlerReset)
	cmdRegistry.register("users", handlerUsers)
	cmdRegistry.register("agg", handlerAgg)
	// Wrap handlers that require a logged-in user with the middleware
	cmdRegistry.register("addfeed", middlewareLoggedIn(handlerAddFeed))
	cmdRegistry.register("follow", middlewareLoggedIn(handlerFollow))
	cmdRegistry.register("following", middlewareLoggedIn(handlerFollowing))
	cmdRegistry.register("unfollow", middlewareLoggedIn(handlerUnfollow))
	cmdRegistry.register("browse", middlewareLoggedIn(handlerBrowse)) // NEW: Register browse command
	cmdRegistry.register("feeds", handlerFeeds)

	// 8. Get command-line arguments passed to the program.
	if len(os.Args) < 2 {
		fmt.Println("Error: Not enough arguments provided.")
		fmt.Println("Usage: gator <command> [args...]")
		os.Exit(1)
	}

	// 9. Parse the command name and its arguments from os.Args.
	commandName := os.Args[1]
	commandArgs := []string{}
	if len(os.Args) > 2 {
		commandArgs = os.Args[2:]
	}

	cmd := command{
		name: commandName,
		args: commandArgs,
	}

	// 10. Run the identified command using the command registry.
	err = cmdRegistry.run(appState, cmd)
	if err != nil {
		fmt.Printf("Error running command '%s': %v\n", cmd.name, err)
		os.Exit(1)
	}
}
